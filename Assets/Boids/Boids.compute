// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//Nach cs.toronto.edu/~dt/siggraph97-course/cwr87/

struct Boid {
	float4x4 m;
	float3 heading;
};

RWStructuredBuffer<Boid> Boids;

cbuffer CB{
	uint boid_amount;
	float4 size;
	float4 position;
	float speed;
};

[numthreads(64,1,1)]
void CSMain ( uint3 id : SV_DispatchThreadID )
{
	float3 avoid_collision = float3(0, 0, 0);
	float3 matchSpeed = float3(0, 0, 0);
	float3 flock = float3(0, 0, 0);

	float3 pos = mul(Boids[id.x].m, float4(0, 0, 0, 1)).xyz;

	//Avoid other boids
	for (uint i = 0; i < boid_amount; ++i) {
		if (i == id.x)
			continue;
		
		float3 other_pos = mul(Boids[i].m, float4(0, 0, 0, 1)).xyz;
		float3 boundaryDistances = pow(max(-1, min( 1, size / (pos - other_pos))) * 1.3, float3(7, 7, 7));

		avoid_collision += boundaryDistances;
		//Fly together with other boids
		matchSpeed += Boids[i].heading * length(avoid_collision);
		//Flocking
		flock += pow((other_pos - pos) / size, float3(3, 3, 3));
	}
	avoid_collision = normalize(avoid_collision) * 0.2;
	
	//Avoid box boundries
	float3 boundaryDistances = pow((position.xyz - pos) * 5 / size, float3(3, 3, 3));
	avoid_collision += boundaryDistances * 0.1;



	//Sum
	Boids[id.x].heading += avoid_collision;
	Boids[id.x].heading += normalize(matchSpeed) * 0.1;
	Boids[id.x].heading += normalize(flock) * 0.08;


	 
	Boids[id.x].heading = normalize( Boids[id.x].heading ) * speed;

	Boids[id.x].m._14 += Boids[id.x].heading.x;
	Boids[id.x].m._24 += Boids[id.x].heading.y;
	Boids[id.x].m._34 += Boids[id.x].heading.z;
}