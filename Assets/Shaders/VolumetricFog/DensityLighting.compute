#include "UnityCG.cginc"
#pragma kernel CSMain

#define PI 3.14159

struct DirLightData 
{
	float4x4 worldToShadow[4];
	float4 lightSplitsNear;
	float4 lightSplitsFar;
	float4 lightColor;
	float4 ambientColor;
	float4 lightDirection;
};
RWStructuredBuffer<DirLightData> lightData;

SamplerState MyPointClampSampler;

Texture2D<float> cascadeShadowMap;
RWTexture3D<half4> fogVolume;
float4 cameraPosition;
float nearPlane;
float farPlane;
float4 frustumRays[4];
float scattering;
float g;
float fogHeight;
float fogFalloff;
float transmittance;
float4 sliceDepths[32];
matrix historyViewProjection;
float logfarOverNearInv;
float4 scatterColor;
float time;

float noiseIntensity;
float noiseSize;
float4 noiseDirection;
float4 ambientLightColor;

struct FogPointLight
{
	float4 position;
    float4 color;
    float range;
    float intensity;
};
RWStructuredBuffer<FogPointLight> pointLights;
int pointLightCount;

float3 volumeResolution;

float3 getCascadeShadowCoords(float3 worldPosition) 
{
	float distToCam = length(worldPosition - cameraPosition.xyz);
	float4 near = float4 (distToCam >= lightData[0].lightSplitsNear); 
	float4 far = float4 (distToCam < lightData[0].lightSplitsFar);
	float4 weights = near * far;

	float3 shadowCoord0 = mul(lightData[0].worldToShadow[0], float4(worldPosition, 1)).xyz; 
	float3 shadowCoord1 = mul(lightData[0].worldToShadow[1], float4(worldPosition, 1)).xyz;
	float3 shadowCoord2 = mul(lightData[0].worldToShadow[2], float4(worldPosition, 1)).xyz;
	float3 shadowCoord3 = mul(lightData[0].worldToShadow[3], float4(worldPosition, 1)).xyz;
	float3 coord = 
		shadowCoord0 * weights.x + 
		shadowCoord1 * weights.y +
		shadowCoord2 * weights.z +
		shadowCoord3 * weights.w;
	return coord;
}

float3 getFrustumRay(float2 uv)
{
	float3 upperRay = lerp(frustumRays[1].xyz, frustumRays[2].xyz, uv.x);
	float3 lowerRay = lerp(frustumRays[0].xyz, frustumRays[3].xyz, uv.x);
	return lerp(lowerRay, upperRay, uv.y);
}

float calcTransmittance(float3 position, float3 lightDirection, float dist)
{
	// integrate optical depth along light ray
	// https://iquilezles.org/www/articles/fog/fog.htm
	float opticalDepth = exp(-fogFalloff * (position.y + dist * lightDirection.y) + fogHeight);
	opticalDepth -= exp(-fogFalloff * position.y + fogHeight);
	opticalDepth /= -fogFalloff * lightDirection.y;
	return exp(-opticalDepth * scattering * transmittance);
}

// noise function copied from here: https://www.ronja-tutorials.com/2018/09/15/perlin-noise.html
float rand3dTo1d(float3 value, float3 dotDir = float3(12.9898, 78.233, 37.719)){
    //make value smaller to avoid artefacts
    float3 smallValue = sin(value);
    //get scalar value from 3d vector
    float random = dot(smallValue, dotDir);
    //make value more random by making it bigger and then taking teh factional part
    random = frac(sin(random) * 143758.5453);
    return random;
}
float3 rand3dTo3d(float3 value){
    return float3(
        rand3dTo1d(value, float3(12.989, 78.233, 37.719)),
        rand3dTo1d(value, float3(39.346, 11.135, 83.155)),
        rand3dTo1d(value, float3(73.156, 52.235, 09.151))
    );
}
float easeIn(float interpolator)
{
	return interpolator * interpolator;
}
float easeOut(float interpolator){
	return 1 - easeIn(1 - interpolator);
}
float easeInOut(float interpolator){
	float easeInValue = easeIn(interpolator);
	float easeOutValue = easeOut(interpolator);
	return lerp(easeInValue, easeOutValue, interpolator);
}
float perlinNoise(float3 value){
	float3 fraction = frac(value);
	float interpolatorX = easeInOut(fraction.x);
	float interpolatorY = easeInOut(fraction.y);
	float interpolatorZ = easeInOut(fraction.z);
	float3 cellNoiseZ[2];
	[unroll]
	for(int z=0;z<=1;z++){
		float3 cellNoiseY[2];
		[unroll]
		for(int y=0;y<=1;y++){
			float3 cellNoiseX[2];
			[unroll]
			for(int x=0;x<=1;x++){
				float3 cell = floor(value) + float3(x, y, z);
				float3 cellDirection = rand3dTo3d(cell) * 2 - 1;
				float3 compareVector = fraction - float3(x, y, z);
				cellNoiseX[x] = dot(cellDirection, compareVector);
			}
			cellNoiseY[y] = lerp(cellNoiseX[0], cellNoiseX[1], interpolatorX);
		}
		cellNoiseZ[z] = lerp(cellNoiseY[0], cellNoiseY[1], interpolatorY);
	}
	float3 noise = lerp(cellNoiseZ[0], cellNoiseZ[1], interpolatorZ);
	return noise;
}

float phaseFunction(float3 pointPosition, float3 lightDirection) 
{
	// Henyey-Greenstein phase function
	float3 viewDir = normalize(pointPosition - cameraPosition);
	float theta = dot(lightDirection, viewDir);
	float phase = 1 - g * g;
	phase /= 4 * PI * pow(1 + g * g - 2 * g * theta, 1.5);
	return phase;
}

[numthreads(4,4,4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float3 volCoord = float3(float3(id) / volumeResolution + 0.5f / volumeResolution);
	//float z = volCoord.z * (farPlane - nearPlane) + nearPlane;
	float z = sliceDepths[id.z / 4][id.z % 4];
	float3 worldPosition = cameraPosition.xyz + z * getFrustumRay(volCoord.xy);

	// 32-tap PCF filter
	float3 shadowCoord = getCascadeShadowCoords(worldPosition);
	float4 shadowDepth = cascadeShadowMap.GatherRed(MyPointClampSampler, shadowCoord.xy, int2(-1, 0));
	float4 visibility = float4(shadowDepth < shadowCoord.z);
	shadowDepth = cascadeShadowMap.GatherRed(MyPointClampSampler, shadowCoord.xy, int2(1, 0));
	visibility += float4(shadowDepth < shadowCoord.z);
	shadowDepth = cascadeShadowMap.GatherRed(MyPointClampSampler, shadowCoord.xy, int2(-1, 2));
	visibility += float4(shadowDepth < shadowCoord.z);
	shadowDepth = cascadeShadowMap.GatherRed(MyPointClampSampler, shadowCoord.xy, int2(1, 2));
	visibility += float4(shadowDepth < shadowCoord.z);
	shadowDepth = cascadeShadowMap.GatherRed(MyPointClampSampler, shadowCoord.xy, int2(-3, -2));
	visibility = float4(shadowDepth < shadowCoord.z);
	shadowDepth = cascadeShadowMap.GatherRed(MyPointClampSampler, shadowCoord.xy, int2(3, 2));
	visibility += float4(shadowDepth < shadowCoord.z);
	shadowDepth = cascadeShadowMap.GatherRed(MyPointClampSampler, shadowCoord.xy, int2(-3, 4));
	visibility += float4(shadowDepth < shadowCoord.z);
	shadowDepth = cascadeShadowMap.GatherRed(MyPointClampSampler, shadowCoord.xy, int2(3, 4));
	visibility += float4(shadowDepth < shadowCoord.z);
	
	visibility.r = dot(visibility, 1/32.0f);
	//float pointDepthExp = exp(shadowCoord.z * 80);
	//float visibility = saturate(shadowDepthExp * pointDepthExp);

	float noise = saturate(perlinNoise((worldPosition + noiseDirection.xyz * time) / noiseSize)) * noiseIntensity + (1 - noiseIntensity);
	noise = noise * 0.8 + 0.2 *saturate(perlinNoise((worldPosition + noiseDirection.xyz * time)));
	scattering *= saturate(exp(-worldPosition.y * fogFalloff + fogHeight) * noise);

	half4 result = half4(ambientLightColor.rgb * 0.1f, scattering);
	float3 scatteredColor = lightData[0].lightColor.rgb * visibility.r;

	// transmittance from directional light to worldPosition
	float transmittance = calcTransmittance(worldPosition, lightData[0].lightDirection, 100000);
	scatteredColor *= transmittance;

	float phase = phaseFunction(worldPosition, lightData[0].lightDirection);
	result.rgb += scatteredColor * phase;

	// point light lighting
	for (int i = 0; i < pointLightCount; i++) 
	{
		FogPointLight light = pointLights[i];
		//inverse-square light attenuation
		float3 lightVector = light.position.xyz - worldPosition;
		float3 lightVecNorm = normalize(lightVector);
		float lightDist = length(lightVector);
		float attentuation = 1 / max(lightDist, 1);
		attentuation *= attentuation;
		phase = phaseFunction(worldPosition, lightVecNorm);
		result.rgb += light.color.rgb * attentuation * phase 
			* light.intensity * calcTransmittance(light.position, lightVecNorm, lightDist);
	}

	result.rgb *= scattering * scatterColor;
	result.rgb *= PI;

	fogVolume[id] = result;
}