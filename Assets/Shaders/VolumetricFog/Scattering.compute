// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWTexture3D<half4> fogVolume;
RWTexture3D<half4> accumulatedFogVolume;
float4 sliceDepths[32];
float4 scatterColor;

float4 accumulateScattering(float3 accumScattering, float accumOpticalDepth, float3 scattering, float opticalDepth, float sliceDepth) 
{
	float newOpticalDepth = accumOpticalDepth + opticalDepth * sliceDepth;
	float3 newScattering = accumScattering + sliceDepth * scattering * exp(-newOpticalDepth * scatterColor.rgb);
	return float4(newScattering, newOpticalDepth);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float4 currentValue = fogVolume[uint3(id.xy, 0)];
	currentValue *= sliceDepths[0][0];
	currentValue.rgb *= exp(-currentValue.a * scatterColor.rgb);
	accumulatedFogVolume[uint3(id.xy, 0)] = half4(currentValue.xyz, exp(-currentValue.a));
    for (uint i = 1; i < 128; i++) 
	{
		float4 nextValue = fogVolume[uint3(id.xy, i)];
		float sd = sliceDepths[i / 4][i % 4] - sliceDepths[(i - 1) / 4][(i - 1) % 4];
		currentValue = accumulateScattering(currentValue.rgb, currentValue.a, nextValue.rgb, nextValue.a, sd);
		accumulatedFogVolume[uint3(id.xy, i)] = half4(currentValue.rgb, exp(-currentValue.a));
	}
}
