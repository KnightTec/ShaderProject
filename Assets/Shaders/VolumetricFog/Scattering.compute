// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWTexture3D<half4> fogVolume;
RWTexture3D<half4> accumulatedFogVolume;
float4 sliceDepths[32];
float4 scatterColor;

float4 accumulateScattering(float3 accumScattering, float accumOpticalDepth, float3 scattering, float opticalDepth, float sd) 
{
	float newOpticalDepth = accumOpticalDepth + opticalDepth * sd;
	float3 newScattering = accumScattering + sd * scattering * exp(-newOpticalDepth * scatterColor);
	return float4(newScattering, newOpticalDepth);
}

void writeOutput(uint3 position, float3 scattering, float transmittance) 
{
	accumulatedFogVolume[position] = float4(scattering, transmittance);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float4 currentValue = fogVolume[uint3(id.xy, 0)];
	
	currentValue *= sliceDepths[0][0];
	currentValue.rgb *= exp(-currentValue.a * scatterColor);
	writeOutput(uint3(id.xy, 0), currentValue.xyz, exp(-currentValue.a));
    for (uint i = 1; i < 128; i++) 
	{
		float4 nextValue = fogVolume[uint3(id.xy, i)];
		float sd = sliceDepths[i / 4][i % 4] - sliceDepths[(i - 1) / 4][(i - 1) % 4];
		currentValue = accumulateScattering(currentValue.rgb, currentValue.a, nextValue.rgb, nextValue.a, sd);
		writeOutput(uint3(id.xy, i), currentValue.rgb, exp(-currentValue.a));
	}
}
